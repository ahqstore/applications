---
import type { GetStaticPathsResult, ImageMetadata } from "astro";
import { decode } from "@msgpack/msgpack";

import * as sizeOf from "image-size";
import { readFileSync, writeFileSync } from "node:fs";
import { stringify } from "smol-toml";
import { join } from "node:path";

import AppLayout from "@/layouts/AppLayout.astro";

import { getImage } from "astro:assets";
import type { AHQStoreApplication } from "ahqstore-types";

const imageFilePaths = import.meta.glob("../../../../../**/db/res/**/*", {
  // Eagerly load the paths during build
  eager: true,
  query: "?url",
});

const genImageFromPath = (height: number, width: number, urlRelative: string) =>
  ({
    // @ts-expect-error We're trying to do something
    src: `${imageFilePaths[urlRelative].default}?origWidth=${width}&origHeight=${height}&origFormat=png`,
    width,
    height,
    format: "png",
  }) as ImageMetadata;

interface Props {
  prefix: string;
  app: string;
  template: string;
  repoDir: string;
  appAssetUrl: string;
}

export async function getStaticPaths(): Promise<GetStaticPathsResult> {
  const output: GetStaticPathsResult = [];

  const toFetch = [
    {
      prefix: "a",
      name: "map_data_ahqstore_json",
      app: "app_url_ahqstore",
      appA: "app_asset_url_ahqstore",
      os: "community",
      repo_dir: "repo_community",
    },
    {
      prefix: "l",
      name: "map_data_linux_json",
      app: "app_url_linux",
      appA: "app_asset_url_linux",
      os: "linux",
      repo_dir: "repo_linux",
    },
    {
      prefix: "f",
      name: "map_data_fdroid_json",
      app: "app_url_fdroid",
      appA: "app_asset_url_fdroid",
      os: "android",
      repo_dir: "repo_fdroid",
    },
    {
      prefix: "w",
      name: "map_data_winget_json",
      app: "app_url_winget",
      appA: "app_asset_url_winget",
      os: "win32",
      repo_dir: "repo_win32",
    },
  ];

  toFetch.forEach(({ name, os, app, appA, prefix, repo_dir }) => {
    const data = decode(
      readFileSync(
        join(import.meta.dirname, `../../../../public/jsondump/${name}`)
      )
    ) as string[];

    const appUrl = readFileSync(
      join(import.meta.dirname, `../../../../public/jsondump/${app}`)
    ).toString();

    const appAssetUrl = readFileSync(
      join(import.meta.dirname, `../../../../public/jsondump/${appA}`)
    ).toString();

    data.forEach((id) => {
      const data = /.:(.*)/;

      const identifier = data.exec(id)!![1];

      output.push({
        params: {
          os,
          app: identifier,
        },
        props: {
          prefix,
          app: identifier,
          template: appUrl,
          appAssetUrl,
          repoDir: repo_dir,
        },
      });
    });
  });

  return output;
}

const { prefix, repoDir, app, template, appAssetUrl } =
  Astro.props as any as Props;

const responsiveWidths = [
  32,
  48,
  64,
  96,
  128,
  256,
  512,
  100,
  200,
  284,
  320, // Small mobile
  640, // Medium mobile / Small tablet
  768, // Tablet / Small desktop
  1024, // Desktop
  1280, // Larger Desktop
  // You might want to include a width up to the maximum display size you expect,
  // but avoid going over the actual display size needed.
  // For a 2000x2000 source, consider the actual space the image will occupy on screen.
  // If your hero section is max 1400px wide, no need for widths > 1400px.
  1440, // Example: common max width for hero on larger screens
];

let appInfo: AHQStoreApplication;
let appImgs = [];

if (import.meta.env.DEV) {
  appInfo = await fetch(template.replace("{APP_ID}", app)).then(async (s) => {
    if (!s.ok) {
      const body = await (await s.blob()).text();
      console.log(body);

      throw new Error("Received an error!");
    }
    return s.json();
  });

  appImgs.push(
    await getImage({
      src: appAssetUrl.replace("{APP_ID}", app).replace("{ASSET}", "0"),
      format: "webp",
      // For LCP, ensure `sizes` attribute is passed to the img tag
      // to help browser pick the right size quickly.
      // This height is for the *output* image. If it's a background, it's just a hint.
      widths: responsiveWidths, // Generate multiple widths
      inferSize: true,
      quality: 80,
    })
  );

  for (let i = 0; i < appInfo.displayImages.length; i++) {
    appImgs.push(
      await getImage({
        src: appAssetUrl
          .replace("{APP_ID}", app)
          .replace("{ASSET}", String(appInfo.displayImages[i])),
        format: "webp",
        // For LCP, ensure `sizes` attribute is passed to the img tag
        // to help browser pick the right size quickly.
        // This height is for the *output* image. If it's a background, it's just a hint.
        widths: responsiveWidths, // Generate multiple widths
        inferSize: true, // Still useful for the aspect ratio
        quality: 80,
      })
    );
  }
} else {
  const json: AHQStoreApplication = JSON.parse(
    readFileSync(
      join(import.meta.dirname, `../../../../../${repoDir}/db/apps/${app}.json`)
    ).toString()
  );

  const iconUrl =
    /*join(
    import.meta.dirname,*/
    `../../../../../${repoDir}/db/res/${app}/{ASSET}`;
  // );

  const assetInfo = join(
    import.meta.dirname,
    `../../../../public/api/v1/assets/${prefix}/${app}_{ASSET}.json`
  );

  // Actual appInfo loading
  const path = join(
    import.meta.dirname,
    `../../../../public/api/v1/${prefix}/${app}.json`
  );

  const path2 = join(
    import.meta.dirname,
    `../../../../public/api/v1/${prefix}/${app}`
  );

  const path3 = join(
    import.meta.dirname,
    `../../../../public/api/v1/${prefix}/${app}.toml`
  );

  writeFileSync(path, JSON.stringify(json));
  writeFileSync(path2, JSON.stringify(json));
  writeFileSync(path3, stringify(json));

  const p = iconUrl.replace("{ASSET}", "0");

  let h = { width: 128, height: 128 };

  try {
    h = sizeOf.default(readFileSync(p));

    const mainIconOpt = await getImage({
      src: genImageFromPath(h.height, h.width, p),
      format: "webp",
      // For LCP, ensure `sizes` attribute is passed to the img tag
      // to help browser pick the right size quickly.
      // This height is for the *output* image. If it's a background, it's just a hint.
      widths: responsiveWidths, // Generate multiple widths
      width: h.width,
      height: h.height,
      quality: 80,
    });

    if (mainIconOpt.src.startsWith("/")) {
      throw new Error("Something's wrong");
    }

    appImgs.push(mainIconOpt);

    writeFileSync(
      assetInfo.replace("{ASSET}", "0"),
      JSON.stringify([mainIconOpt.src, mainIconOpt.srcSet.attribute])
    );
  } catch (e) {
    appImgs.push(null as any);
    console.error(`🚨 Failed to load (sizeof) main icon of ${p}`);
  }

  for (let i = 0; i < json.displayImages.length; i++) {
    const p = iconUrl.replace("{ASSET}", String(json.displayImages[i]));

    let dimensions = { width: 128, height: 128 }; // Safe fallback size

    try {
      dimensions = sizeOf.default(readFileSync(p));

      const ic = await getImage({
        src: genImageFromPath(h.height, h.width, p),
        format: "webp",
        // For LCP, ensure `sizes` attribute is passed to the img tag
        // to help browser pick the right size quickly.
        // This height is for the *output* image. If it's a background, it's just a hint.
        widths: responsiveWidths, // Generate multiple widths
        width: dimensions.width,
        height: dimensions.height,
        quality: 80,
      });
      appImgs.push(ic);

      writeFileSync(
        assetInfo.replace("{ASSET}", String(json.displayImages[i])),
        JSON.stringify([ic.src, ic.srcSet.attribute])
      );
    } catch (e) {
      appImgs.push(null as any);
      console.error("⚠️ Failed to load " + p);
    }
  }

  appInfo = json;
}
---

<AppLayout>
  {JSON.stringify(appInfo, null, 4)}
  {JSON.stringify(appImgs, null, 4)}
</AppLayout>
